{"ast":null,"code":"var __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nimport { until } from \"@open-draft/until\";\nimport { getResponse } from './getResponse.mjs';\nimport { devUtils } from './internal/devUtils.mjs';\nimport { onUnhandledRequest } from './request/onUnhandledRequest.mjs';\nimport { readResponseCookies } from './request/readResponseCookies.mjs';\nfunction handleRequest(request, requestId, handlers, options, emitter, handleRequestOptions) {\n  return __async(this, null, function* () {\n    var _a, _b, _c, _d, _e, _f;\n    emitter.emit(\"request:start\", request, requestId);\n    if (request.headers.get(\"x-msw-intention\") === \"bypass\") {\n      emitter.emit(\"request:end\", request, requestId);\n      (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n      return;\n    }\n    const lookupResult = yield until(() => {\n      return getResponse(request, handlers, handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext);\n    });\n    if (lookupResult.error) {\n      emitter.emit(\"unhandledException\", lookupResult.error, request, requestId);\n      throw lookupResult.error;\n    }\n    const {\n      handler,\n      response\n    } = lookupResult.data;\n    if (!handler) {\n      yield onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n      emitter.emit(\"request:unhandled\", request, requestId);\n      emitter.emit(\"request:end\", request, requestId);\n      (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n      return;\n    }\n    if (!response) {\n      devUtils.warn(`Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`, response, handler.info.header, handler.info.callFrame);\n      emitter.emit(\"request:end\", request, requestId);\n      (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n      return;\n    }\n    if (response.status === 302 && response.headers.get(\"x-msw-intention\") === \"passthrough\") {\n      emitter.emit(\"request:end\", request, requestId);\n      (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n      return;\n    }\n    response.headers.set(\"x-powered-by\", \"msw\");\n    readResponseCookies(request, response);\n    emitter.emit(\"request:match\", request, requestId);\n    const requiredLookupResult = lookupResult.data;\n    const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response)) || response;\n    (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n    emitter.emit(\"request:end\", request, requestId);\n    return transformedResponse;\n  });\n}\nexport { handleRequest };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}