{"ast":null,"code":"var __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nimport jsLevenshtein from \"@bundled-es-modules/js-levenshtein\";\nimport { RestHandler, GraphQLHandler } from '../../index.mjs';\nimport { parseGraphQLRequest } from '../internal/parseGraphQLRequest.mjs';\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest.mjs';\nimport { isStringEqual } from '../internal/isStringEqual.mjs';\nimport { devUtils } from '../internal/devUtils.mjs';\nconst getStringMatchScore = jsLevenshtein;\nconst MAX_MATCH_SCORE = 3;\nconst MAX_SUGGESTION_COUNT = 4;\nconst TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = getStringMatchScore(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = getStringMatchScore(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(([leftScore], [rightScore]) => leftScore - rightScore).filter(([score]) => score <= MAX_MATCH_SCORE).slice(0, MAX_SUGGESTION_COUNT).map(([, handler]) => handler);\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map(handler => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers, strategy = \"warn\") {\n  return __async(this, null, function* () {\n    const parsedGraphQLQuery = yield parseGraphQLRequest(request).catch(() => null);\n    function generateHandlerSuggestion() {\n      const handlerGroups = groupHandlersByType(handlers);\n      const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n      const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n      return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n    }\n    function generateUnhandledRequestMessage() {\n      const publicUrl = getPublicUrlFromRequest(request);\n      const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n      const handlerSuggestion = generateHandlerSuggestion();\n      const messageTemplate = [`captured a request without a matching request handler:`, `  \\u2022 ${requestHeader}`, handlerSuggestion, `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`].filter(Boolean);\n      return messageTemplate.join(\"\\n\\n\");\n    }\n    function applyStrategy(strategy2) {\n      const message = generateUnhandledRequestMessage();\n      switch (strategy2) {\n        case \"error\":\n          {\n            devUtils.error(\"Error: %s\", message);\n            throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n          }\n        case \"warn\":\n          {\n            devUtils.warn(\"Warning: %s\", message);\n            break;\n          }\n        case \"bypass\":\n          break;\n        default:\n          throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n      }\n    }\n    if (typeof strategy === \"function\") {\n      strategy(request, {\n        warning: applyStrategy.bind(null, \"warn\"),\n        error: applyStrategy.bind(null, \"error\")\n      });\n      return;\n    }\n    applyStrategy(strategy);\n  });\n}\nexport { onUnhandledRequest };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}