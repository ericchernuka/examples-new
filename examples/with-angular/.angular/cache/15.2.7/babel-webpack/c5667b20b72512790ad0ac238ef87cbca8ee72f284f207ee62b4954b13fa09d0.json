{"ast":null,"code":"import _asyncToGenerator from \"/Users/kettanaito/Projects/mswjs/new-examples/node_modules/.pnpm/@babel+runtime@7.20.13/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { decodeBuffer, encodeBuffer, toArrayBuffer } from \"./chunk-UYUNRMLU.mjs\";\nimport { toInteractiveRequest, uuidv4 } from \"./chunk-RT3ATOJH.mjs\";\nimport { IS_PATCHED_MODULE, Interceptor } from \"./chunk-O7B67YBY.mjs\";\n\n// src/interceptors/XMLHttpRequest/index.ts\nimport { invariant as invariant2 } from \"outvariant\";\n\n// src/interceptors/XMLHttpRequest/XMLHttpRequestProxy.ts\nimport { until } from \"@open-draft/until\";\n\n// src/interceptors/XMLHttpRequest/XMLHttpRequestController.ts\nimport { headersToString } from \"headers-polyfill\";\n\n// src/interceptors/XMLHttpRequest/utils/concatArrayBuffer.ts\nfunction concatArrayBuffer(left, right) {\n  const result = new Uint8Array(left.byteLength + right.byteLength);\n  result.set(left, 0);\n  result.set(right, left.byteLength);\n  return result;\n}\n\n// src/interceptors/XMLHttpRequest/polyfills/EventPolyfill.ts\nvar EventPolyfill = class {\n  constructor(type, options) {\n    this.AT_TARGET = 0;\n    this.BUBBLING_PHASE = 0;\n    this.CAPTURING_PHASE = 0;\n    this.NONE = 0;\n    this.type = \"\";\n    this.srcElement = null;\n    this.currentTarget = null;\n    this.eventPhase = 0;\n    this.isTrusted = true;\n    this.composed = false;\n    this.cancelable = true;\n    this.defaultPrevented = false;\n    this.bubbles = true;\n    this.lengthComputable = true;\n    this.loaded = 0;\n    this.total = 0;\n    this.cancelBubble = false;\n    this.returnValue = true;\n    this.type = type;\n    this.target = (options == null ? void 0 : options.target) || null;\n    this.currentTarget = (options == null ? void 0 : options.currentTarget) || null;\n    this.timeStamp = Date.now();\n  }\n  composedPath() {\n    return [];\n  }\n  initEvent(type, bubbles, cancelable) {\n    this.type = type;\n    this.bubbles = !!bubbles;\n    this.cancelable = !!cancelable;\n  }\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n  stopPropagation() {}\n  stopImmediatePropagation() {}\n};\n\n// src/interceptors/XMLHttpRequest/polyfills/ProgressEventPolyfill.ts\nvar ProgressEventPolyfill = class extends EventPolyfill {\n  constructor(type, init) {\n    super(type);\n    this.lengthComputable = (init == null ? void 0 : init.lengthComputable) || false;\n    this.composed = (init == null ? void 0 : init.composed) || false;\n    this.loaded = (init == null ? void 0 : init.loaded) || 0;\n    this.total = (init == null ? void 0 : init.total) || 0;\n  }\n};\n\n// src/interceptors/XMLHttpRequest/utils/createEvent.ts\nvar SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== \"undefined\";\nfunction createEvent(target, type, init) {\n  const progressEvents = [\"error\", \"progress\", \"loadstart\", \"loadend\", \"load\", \"timeout\", \"abort\"];\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT ? ProgressEvent : ProgressEventPolyfill;\n  const event = progressEvents.includes(type) ? new ProgressEventClass(type, {\n    lengthComputable: true,\n    loaded: (init == null ? void 0 : init.loaded) || 0,\n    total: (init == null ? void 0 : init.total) || 0\n  }) : new EventPolyfill(type, {\n    target,\n    currentTarget: target\n  });\n  return event;\n}\n\n// src/utils/createProxy.ts\nfunction createProxy(target, options) {\n  const proxy = new Proxy(target, optionsToProxyHandler(options));\n  return proxy;\n}\nfunction optionsToProxyHandler(options) {\n  const {\n    constructorCall,\n    methodCall,\n    getProperty,\n    setProperty\n  } = options;\n  const handler = {};\n  if (typeof constructorCall !== \"undefined\") {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target, args, newTarget);\n      return constructorCall.call(newTarget, args, next);\n    };\n  }\n  handler.set = function (target, propertyName, nextValue, receiver) {\n    const next = () => {\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(target, propertyName);\n      if (typeof (ownDescriptors == null ? void 0 : ownDescriptors.set) !== \"undefined\") {\n        ownDescriptors.set.apply(target, [nextValue]);\n        return true;\n      }\n      return Reflect.defineProperty(target, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue\n      });\n    };\n    if (typeof setProperty !== \"undefined\") {\n      return setProperty.call(target, [propertyName, nextValue], next);\n    }\n    return next();\n  };\n  handler.get = function (target, propertyName, receiver) {\n    const next = () => target[propertyName];\n    const value = typeof getProperty !== \"undefined\" ? getProperty.call(target, [propertyName, receiver], next) : next();\n    if (typeof value === \"function\") {\n      return (...args) => {\n        const next2 = value.bind(target, ...args);\n        if (typeof methodCall !== \"undefined\") {\n          return methodCall.call(target, [propertyName, args], next2);\n        }\n        return next2();\n      };\n    }\n    return value;\n  };\n  return handler;\n}\n\n// src/interceptors/XMLHttpRequest/utils/isDomParserSupportedType.ts\nfunction isDomParserSupportedType(type) {\n  const supportedTypes = [\"application/xhtml+xml\", \"application/xml\", \"image/svg+xml\", \"text/html\", \"text/xml\"];\n  return supportedTypes.some(supportedType => {\n    return type.startsWith(supportedType);\n  });\n}\n\n// src/utils/parseJson.ts\nfunction parseJson(data) {\n  try {\n    const json = JSON.parse(data);\n    return json;\n  } catch (_) {\n    return null;\n  }\n}\n\n// src/interceptors/XMLHttpRequest/utils/createResponse.ts\nimport { stringToHeaders } from \"headers-polyfill\";\nfunction createResponse(request, responseBody) {\n  return new Response(responseBody, {\n    status: request.status,\n    statusText: request.statusText,\n    headers: stringToHeaders(request.getAllResponseHeaders())\n  });\n}\n\n// src/interceptors/XMLHttpRequest/XMLHttpRequestController.ts\nimport { invariant } from \"outvariant\";\nvar XMLHttpRequestController = class {\n  constructor(initialRequest, logger) {\n    this.initialRequest = initialRequest;\n    this.logger = logger;\n    this.method = \"GET\";\n    this.url = null;\n    this.events = /* @__PURE__ */new Map();\n    this.requestHeaders = new Headers();\n    this.responseBuffer = new Uint8Array();\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case \"ontimeout\":\n            {\n              const eventName = propertyName.slice(2);\n              this.request.addEventListener(eventName, nextValue);\n              return invoke();\n            }\n          default:\n            {\n              return invoke();\n            }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        var _a;\n        switch (methodName) {\n          case \"open\":\n            {\n              const [method, url] = args;\n              this.requestId = uuidv4();\n              if (typeof url === \"undefined\") {\n                this.method = \"GET\";\n                this.url = toAbsoluteUrl(method);\n              } else {\n                this.method = method;\n                this.url = toAbsoluteUrl(url);\n              }\n              this.logger = this.logger.extend(`${this.method} ${this.url.href}`);\n              this.logger.info(\"open\", this.method, this.url.href);\n              return invoke();\n            }\n          case \"addEventListener\":\n            {\n              const [eventName, listener] = args;\n              this.registerEvent(eventName, listener);\n              this.logger.info(\"addEventListener\", eventName, listener.name);\n              return invoke();\n            }\n          case \"setRequestHeader\":\n            {\n              const [name, value] = args;\n              this.requestHeaders.set(name, value);\n              this.logger.info(\"setRequestHeader\", name, value);\n              return invoke();\n            }\n          case \"send\":\n            {\n              const [body] = args;\n              if (body != null) {\n                this.requestBody = typeof body === \"string\" ? encodeBuffer(body) : body;\n              }\n              this.request.addEventListener(\"load\", () => {\n                if (typeof this.onResponse !== \"undefined\") {\n                  const fetchResponse = createResponse(this.request, this.request.response);\n                  this.onResponse.call(this, fetchResponse, fetchRequest, this.requestId);\n                }\n              });\n              const fetchRequest = this.toFetchApiRequest();\n              const onceRequestSettled = ((_a = this.onRequest) == null ? void 0 : _a.call(this, fetchRequest, this.requestId)) || Promise.resolve();\n              onceRequestSettled.finally(() => {\n                if (this.request.readyState < this.request.LOADING) {\n                  this.logger.info(\"request callback settled but request has not been handled (readystate %d), performing as-is...\", this.request.readyState);\n                  this.request.setRequestHeader(\"X-Request-Id\", this.requestId);\n                  return invoke();\n                }\n              });\n              break;\n            }\n          default:\n            {\n              return invoke();\n            }\n        }\n      }\n    });\n  }\n  registerEvent(eventName, listener) {\n    const prevEvents = this.events.get(eventName) || [];\n    const nextEvents = prevEvents.concat(listener);\n    this.events.set(eventName, nextEvents);\n    this.logger.info('registered event \"%s\"', eventName, listener.name);\n  }\n  respondWith(response) {\n    var _this = this;\n    this.logger.info(\"responding with a mocked response: %d %s\", response.status, response.statusText);\n    define(this.request, \"status\", response.status);\n    define(this.request, \"statusText\", response.statusText);\n    define(this.request, \"responseURL\", this.url.href);\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args) => {\n        this.logger.info(\"getResponseHeader\", args[0]);\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info(\"headers not received yet, returning null\");\n          return null;\n        }\n        const headerValue = response.headers.get(args[0]);\n        this.logger.info('resolved response header \"%s\" to', args[0], headerValue);\n        return headerValue;\n      }\n    });\n    this.request.getAllResponseHeaders = new Proxy(this.request.getAllResponseHeaders, {\n      apply: () => {\n        this.logger.info(\"getAllResponseHeaders\");\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info(\"headers not received yet, returning empty string\");\n          return \"\";\n        }\n        const allHeaders = headersToString(response.headers);\n        this.logger.info(\"resolved all response headers to\", allHeaders);\n        return allHeaders;\n      }\n    });\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML\n      }\n    });\n    const totalResponseBodyLength = response.headers.has(\"Content-Length\") ? Number(response.headers.get(\"Content-Length\")) : void 0;\n    this.logger.info(\"calculated response body length\", totalResponseBodyLength);\n    this.trigger(\"loadstart\", {\n      loaded: 0,\n      total: totalResponseBodyLength\n    });\n    this.setReadyState(this.request.HEADERS_RECEIVED);\n    this.setReadyState(this.request.LOADING);\n    const finalizeResponse = () => {\n      this.logger.info(\"finalizing the mocked response...\");\n      this.setReadyState(this.request.DONE);\n      this.trigger(\"load\", {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n      this.trigger(\"loadend\", {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength\n      });\n    };\n    if (response.body) {\n      this.logger.info(\"mocked response has body, streaming...\");\n      const reader = response.body.getReader();\n      const readNextResponseBodyChunk = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* () {\n          const {\n            value,\n            done\n          } = yield reader.read();\n          if (done) {\n            _this.logger.info(\"response body stream done!\");\n            finalizeResponse();\n            return;\n          }\n          if (value) {\n            _this.logger.info(\"read response body chunk:\", value);\n            _this.responseBuffer = concatArrayBuffer(_this.responseBuffer, value);\n            _this.trigger(\"progress\", {\n              loaded: _this.responseBuffer.byteLength,\n              total: totalResponseBodyLength\n            });\n          }\n          readNextResponseBodyChunk();\n        });\n        return function readNextResponseBodyChunk() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      readNextResponseBodyChunk();\n    } else {\n      finalizeResponse();\n    }\n  }\n  responseBufferToText() {\n    return decodeBuffer(this.responseBuffer);\n  }\n  get response() {\n    this.logger.info(\"getResponse (responseType: %s)\", this.request.responseType);\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n    switch (this.request.responseType) {\n      case \"json\":\n        {\n          const responseJson = parseJson(this.responseBufferToText());\n          this.logger.info(\"resolved response JSON\", responseJson);\n          return responseJson;\n        }\n      case \"arraybuffer\":\n        {\n          const arrayBuffer = toArrayBuffer(this.responseBuffer);\n          this.logger.info(\"resolved response ArrayBuffer\", arrayBuffer);\n          return arrayBuffer;\n        }\n      case \"blob\":\n        {\n          const mimeType = this.request.getResponseHeader(\"Content-Type\") || \"text/plain\";\n          const responseBlob = new Blob([this.responseBufferToText()], {\n            type: mimeType\n          });\n          this.logger.info(\"resolved response Blob (mime type: %s)\", responseBlob, mimeType);\n          return responseBlob;\n        }\n      default:\n        {\n          const responseText = this.responseBufferToText();\n          this.logger.info('resolving \"%s\" response type as text', this.request.responseType, responseText);\n          return responseText;\n        }\n    }\n  }\n  get responseText() {\n    invariant(this.request.responseType === \"\" || this.request.responseType === \"text\", \"InvalidStateError: The object is in invalid state.\");\n    if (this.request.readyState !== this.request.LOADING && this.request.readyState !== this.request.DONE) {\n      return \"\";\n    }\n    const responseText = this.responseBufferToText();\n    this.logger.info('getResponseText: \"%s\"', responseText);\n    return responseText;\n  }\n  get responseXML() {\n    invariant(this.request.responseType === \"\" || this.request.responseType === \"document\", \"InvalidStateError: The object is in invalid state.\");\n    if (this.request.readyState !== this.request.DONE) {\n      return null;\n    }\n    const contentType = this.request.getResponseHeader(\"Content-Type\") || \"\";\n    if (typeof DOMParser === \"undefined\") {\n      console.warn(\"Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.\");\n      return null;\n    }\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(this.responseBufferToText(), contentType);\n    }\n    return null;\n  }\n  errorWith(error) {\n    this.logger.info(\"responding with an error\");\n    this.setReadyState(this.request.DONE);\n    this.trigger(\"error\");\n    this.trigger(\"loadend\");\n  }\n  setReadyState(nextReadyState) {\n    this.logger.info(\"setReadyState: %d -> %d\", this.request.readyState, nextReadyState);\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info(\"ready state identical, skipping transition...\");\n      return;\n    }\n    define(this.request, \"readyState\", nextReadyState);\n    this.logger.info(\"set readyState to: %d\", nextReadyState);\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggerring \"readystatechange\" event...');\n      this.trigger(\"readystatechange\");\n    }\n  }\n  trigger(eventName, options) {\n    const callback = this.request[`on${eventName}`];\n    const event = createEvent(this.request, eventName, options);\n    this.logger.info('trigger \"%s\"', eventName, options || \"\");\n    if (typeof callback === \"function\") {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName);\n      callback.call(this.request, event);\n    }\n    for (const [registeredEventName, listeners] of this.events) {\n      if (registeredEventName === eventName) {\n        this.logger.info('found %d listener(s) for \"%s\" event, calling...', listeners.length, eventName);\n        listeners.forEach(listener => listener.call(this.request, event));\n      }\n    }\n  }\n  toFetchApiRequest() {\n    this.logger.info(\"converting request to a Fetch API Request...\");\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      credentials: this.request.withCredentials ? \"include\" : \"same-origin\",\n      body: this.requestBody\n    });\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case \"append\":\n          case \"set\":\n            {\n              const [headerName, headerValue] = args;\n              this.request.setRequestHeader(headerName, headerValue);\n              break;\n            }\n          case \"delete\":\n            {\n              const [headerName] = args;\n              console.warn(`XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`);\n              break;\n            }\n        }\n        return invoke();\n      }\n    });\n    define(fetchRequest, \"headers\", proxyHeaders);\n    this.logger.info(\"converted request to a Fetch API Request!\", fetchRequest);\n    return fetchRequest;\n  }\n};\nfunction toAbsoluteUrl(url) {\n  return new URL(url.toString(), location.href);\n}\nfunction define(target, property, value) {\n  Reflect.defineProperty(target, property, {\n    writable: true,\n    enumerable: true,\n    value\n  });\n}\n\n// src/interceptors/XMLHttpRequest/XMLHttpRequestProxy.ts\nfunction createXMLHttpRequestProxy({\n  emitter,\n  logger\n}) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info(\"constructed new XMLHttpRequest\");\n      const originalRequest = Reflect.construct(target, args, newTarget);\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(target.prototype);\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(originalRequest, propertyName, prototypeDescriptors[propertyName]);\n      }\n      const requestController = new XMLHttpRequestController(originalRequest, logger);\n      requestController.onRequest = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (request, requestId) {\n          var _this2 = this;\n          const interactiveRequest = toInteractiveRequest(request);\n          this.logger.info('emitting the \"request\" event for %s listener(s)...', emitter.listenerCount(\"request\"));\n          emitter.emit(\"request\", interactiveRequest, requestId);\n          this.logger.info(\"awaiting mocked response...\");\n          const resolverResult = yield until( /*#__PURE__*/_asyncToGenerator(function* () {\n            yield emitter.untilIdle(\"request\", ({\n              args: [, pendingRequestId]\n            }) => {\n              return pendingRequestId === requestId;\n            });\n            _this2.logger.info('all \"request\" listeners settled!');\n            const [mockedResponse2] = yield interactiveRequest.respondWith.invoked();\n            _this2.logger.info(\"event.respondWith called with:\", mockedResponse2);\n            return mockedResponse2;\n          }));\n          if (resolverResult.error) {\n            this.logger.info(\"request listener threw an exception, aborting request...\", resolverResult.error);\n            requestController.errorWith(resolverResult.error);\n            return;\n          }\n          const mockedResponse = resolverResult.data;\n          if (typeof mockedResponse !== \"undefined\") {\n            this.logger.info(\"received mocked response: %d %s\", mockedResponse.status, mockedResponse.statusText);\n            return requestController.respondWith(mockedResponse);\n          }\n          this.logger.info(\"no mocked response received, performing request as-is...\");\n        });\n        return function (_x, _x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n      requestController.onResponse = /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (response, request, requestId) {\n          this.logger.info('emitting the \"response\" event for %s listener(s)...', emitter.listenerCount(\"response\"));\n          emitter.emit(\"response\", response, request, requestId);\n        });\n        return function (_x3, _x4, _x5) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n      return requestController.request;\n    }\n  });\n  return XMLHttpRequestProxy;\n}\n\n// src/interceptors/XMLHttpRequest/index.ts\nvar _XMLHttpRequestInterceptor = class extends Interceptor {\n  constructor() {\n    super(_XMLHttpRequestInterceptor.interceptorSymbol);\n  }\n  checkEnvironment() {\n    return typeof globalThis.XMLHttpRequest !== \"undefined\";\n  }\n  setup() {\n    const logger = this.logger.extend(\"setup\");\n    logger.info('patching \"XMLHttpRequest\" module...');\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest;\n    invariant2(!PureXMLHttpRequest[IS_PATCHED_MODULE], 'Failed to patch the \"XMLHttpRequest\" module: already patched.');\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger\n    });\n    logger.info('native \"XMLHttpRequest\" module patched!', globalThis.XMLHttpRequest.name);\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.XMLHttpRequest = PureXMLHttpRequest;\n      logger.info('native \"XMLHttpRequest\" module restored!', globalThis.XMLHttpRequest.name);\n    });\n  }\n};\nvar XMLHttpRequestInterceptor = _XMLHttpRequestInterceptor;\nXMLHttpRequestInterceptor.interceptorSymbol = Symbol(\"xhr\");\nexport { XMLHttpRequestInterceptor };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}