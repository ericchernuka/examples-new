{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nimport { invariant } from \"outvariant\";\nimport { getCallFrame } from '../utils/internal/getCallFrame.mjs';\nimport { isIterable } from '../utils/internal/isIterable.mjs';\nclass RequestHandler {\n  constructor(options) {\n    this.resolver = options.resolver;\n    this.once = options.once || false;\n    const callFrame = getCallFrame(new Error());\n    this.info = __spreadProps(__spreadValues({}, options.info), {\n      callFrame\n    });\n    this.isUsed = false;\n  }\n  /**\n   * Parse the captured request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  parse(_request, _resolutionContext) {\n    return __async(this, null, function* () {\n      return {};\n    });\n  }\n  /**\n   * Test if this handler matches the given request.\n   */\n  test(request, resolutionContext) {\n    return __async(this, null, function* () {\n      return this.predicate(request, yield this.parse(request.clone(), resolutionContext), resolutionContext);\n    });\n  }\n  extendInfo(_request, _parsedResult) {\n    return {};\n  }\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  run(request, resolutionContext) {\n    return __async(this, null, function* () {\n      if (this.isUsed && this.once) {\n        return null;\n      }\n      this.isUsed = true;\n      const requestClone = request.clone();\n      const parsedResult = yield this.parse(request.clone(), resolutionContext);\n      const shouldInterceptRequest = this.predicate(request.clone(), parsedResult, resolutionContext);\n      if (!shouldInterceptRequest) {\n        return null;\n      }\n      const executeResolver = this.wrapResolver(this.resolver);\n      const resolverExtras = this.extendInfo(request, parsedResult);\n      const mockedResponse = yield executeResolver(__spreadProps(__spreadValues({}, resolverExtras), {\n        request\n      }));\n      const executionResult = this.createExecutionResult(\n      // Pass the cloned request to the result so that logging\n      // and other consumers could read its body once more.\n      requestClone, parsedResult, mockedResponse);\n      return executionResult;\n    });\n  }\n  wrapResolver(resolver) {\n    return info => __async(this, null, function* () {\n      const result = this.resolverGenerator || (yield resolver(info));\n      if (isIterable(result)) {\n        this.isUsed = false;\n        const {\n          value,\n          done\n        } = result[Symbol.iterator]().next();\n        const nextResponse = yield value;\n        if (done) {\n          this.isUsed = true;\n        }\n        if (!nextResponse && done) {\n          invariant(this.resolverGeneratorResult, \"Failed to returned a previously stored generator response: the value is not a valid Response.\");\n          return this.resolverGeneratorResult.clone();\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        if (nextResponse) {\n          this.resolverGeneratorResult = nextResponse == null ? void 0 : nextResponse.clone();\n        }\n        return nextResponse;\n      }\n      return result;\n    });\n  }\n  createExecutionResult(request, parsedResult, response) {\n    return {\n      handler: this,\n      parsedResult,\n      request,\n      response\n    };\n  }\n}\nexport { RequestHandler };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}