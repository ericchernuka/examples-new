{"ast":null,"code":"var __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nimport { invariant } from \"outvariant\";\nimport { Headers } from \"headers-polyfill\";\nfunction bypass(input, init) {\n  return __async(this, null, function* () {\n    if (isRequest(input)) {\n      invariant(!input.bodyUsed, 'Failed to create a bypassed request to \"%s %s\": given request instance already has its body read. Make sure to clone the intercepted request if you wish to read its body before bypassing it.', input.method, input.url);\n    }\n    const url = isRequest(input) ? input.url : input.toString();\n    const resolvedInit = typeof init !== \"undefined\" ? init : yield getRequestInit(input);\n    const headers = new Headers(resolvedInit.headers);\n    headers.set(\"x-msw-intention\", \"bypass\");\n    resolvedInit.headers = headers;\n    return [url, resolvedInit];\n  });\n}\nfunction isRequest(input) {\n  return typeof input === \"object\" && input.constructor.name === \"Request\" && \"clone\" in input && typeof input.clone === \"function\";\n}\nfunction getRequestInit(input) {\n  return __async(this, null, function* () {\n    if (!isRequest(input)) {\n      return {};\n    }\n    const init = {\n      // Set each request init property explicitly\n      // to prevent leaking internal properties of whichever\n      // Request polyfill provided as the input.\n      mode: input.mode,\n      method: input.method,\n      cache: input.cache,\n      headers: input.headers,\n      credentials: input.credentials,\n      signal: input.signal,\n      referrerPolicy: input.referrerPolicy,\n      referrer: input.referrer,\n      redirect: input.redirect,\n      integrity: input.integrity,\n      keepalive: input.keepalive\n    };\n    if (init.method !== \"HEAD\" && input.method !== \"GET\") {\n      init.body = yield input.clone().arrayBuffer();\n      init.duplex = input.duplex;\n    }\n    return init;\n  });\n}\nexport { bypass };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}