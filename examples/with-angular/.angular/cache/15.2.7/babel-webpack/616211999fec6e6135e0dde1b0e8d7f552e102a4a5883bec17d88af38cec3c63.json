{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/browser/setupWorker/setupWorker.ts\nimport { invariant } from \"outvariant\";\nimport { isNodeProcess } from \"is-node-process\";\n\n// src/browser/setupWorker/start/createStartHandler.ts\nimport { until as until3 } from \"@open-draft/until\";\nimport { devUtils as devUtils6 } from '../core/utils/internal/devUtils.mjs';\n\n// src/browser/setupWorker/start/utils/getWorkerInstance.ts\nimport { until } from \"@open-draft/until\";\nimport { devUtils } from '../core/utils/internal/devUtils.mjs';\n\n// src/browser/utils/getAbsoluteWorkerUrl.ts\nfunction getAbsoluteWorkerUrl(workerUrl) {\n  return new URL(workerUrl, location.href).href;\n}\n\n// src/browser/setupWorker/start/utils/getWorkerByRegistration.ts\nfunction getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const relevantStates = allStates.filter(state => {\n    return state != null;\n  });\n  const worker = relevantStates.find(worker2 => {\n    return findWorker(worker2.scriptURL, absoluteWorkerUrl);\n  });\n  return worker || null;\n}\n\n// src/browser/setupWorker/start/utils/getWorkerInstance.ts\nvar getWorkerInstance = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (url, options = {}, findWorker) {\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = yield navigator.serviceWorker.getRegistrations().then(registrations => registrations.filter(registration => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n  const [existingRegistration] = mockRegistrations;\n  if (existingRegistration) {\n    return existingRegistration.update().then(() => {\n      return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n    });\n  }\n  const registrationResult = yield until(() => __async(void 0, null, function* () {\n    const registration = yield navigator.serviceWorker.register(url, options);\n    return [\n    // Compare existing worker registration by its worker URL,\n    // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n    getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n  }));\n  if (registrationResult.error) {\n    const isWorkerMissing = registrationResult.error.message.includes(\"(404)\");\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options == null ? void 0 : options.scope) || \"/\", location.href);\n      throw new Error(devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));\n    }\n    throw new Error(devUtils.formatMessage(\"Failed to register the Service Worker:\\n\\n%s\", registrationResult.error.message));\n  }\n  return registrationResult.data;\n});\n\n// src/browser/setupWorker/start/utils/enableMocking.ts\nimport { devUtils as devUtils3 } from '../core/utils/internal/devUtils.mjs';\n\n// src/browser/setupWorker/start/utils/printStartMessage.ts\nimport { devUtils as devUtils2 } from '../core/utils/internal/devUtils.mjs';\nfunction printStartMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(`%c${devUtils2.formatMessage(message)}`, \"color:orangered;font-weight:bold;\");\n  console.log(\"%cDocumentation: %chttps://mswjs.io/docs\", \"font-weight:bold\", \"font-weight:normal\");\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n  console.groupEnd();\n}\n\n// src/browser/setupWorker/start/utils/enableMocking.ts\nfunction enableMocking(context, options) {\n  return __async(this, null, function* () {\n    var _a, _b;\n    context.workerChannel.send(\"MOCK_ACTIVATE\");\n    yield context.events.once(\"MOCKING_ENABLED\");\n    if (context.isMockingEnabled) {\n      devUtils3.warn(`Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`);\n      return;\n    }\n    context.isMockingEnabled = true;\n    printStartMessage({\n      quiet: options.quiet,\n      workerScope: (_a = context.registration) == null ? void 0 : _a.scope,\n      workerUrl: (_b = context.worker) == null ? void 0 : _b.scriptURL\n    });\n  });\n}\n\n// src/browser/setupWorker/start/utils/createMessageChannel.ts\nvar WorkerChannel = class {\n  constructor(port) {\n    this.port = port;\n  }\n  postMessage(event, ...rest) {\n    const [data, transfer] = rest;\n    this.port.postMessage({\n      type: event,\n      data\n    }, {\n      // @ts-ignore ReadableStream can be transferred\n      // but TypeScript doesn't acknowledge that.\n      transfer\n    });\n  }\n};\n\n// src/browser/setupWorker/start/createRequestListener.ts\nimport { NetworkError } from '../core/NetworkError.mjs';\n\n// src/browser/utils/pruneGetRequestBody.ts\nfunction pruneGetRequestBody(request) {\n  if ([\"HEAD\", \"GET\"].includes(request.method)) {\n    return void 0;\n  }\n  return request.body;\n}\n\n// src/browser/utils/parseWorkerRequest.ts\nfunction parseWorkerRequest(incomingRequest) {\n  return new Request(incomingRequest.url, __spreadProps(__spreadValues({}, incomingRequest), {\n    body: pruneGetRequestBody(incomingRequest)\n  }));\n}\n\n// src/browser/setupWorker/start/createRequestListener.ts\nimport { handleRequest } from '../core/utils/handleRequest.mjs';\nimport { devUtils as devUtils4 } from '../core/utils/internal/devUtils.mjs';\nimport { toResponseInit } from '../core/utils/toResponseInit.mjs';\nvar createRequestListener = (context, options) => {\n  return (event, message) => __async(void 0, null, function* () {\n    var _b;\n    const messageChannel = new WorkerChannel(event.ports[0]);\n    const requestId = message.payload.id;\n    const request = parseWorkerRequest(message.payload);\n    try {\n      let _a;\n      yield handleRequest(request, requestId, context.requestHandlers, options, context.emitter, {\n        onPassthroughResponse() {\n          messageChannel.postMessage(\"NOT_FOUND\");\n        },\n        onMockedResponse(_0, _1) {\n          return __async(this, arguments, function* (response, {\n            request: request2,\n            handler,\n            parsedRequest\n          }) {\n            const responseClone = response.clone();\n            const responseInit = toResponseInit(response);\n            const responseStream = responseClone.body;\n            messageChannel.postMessage(\"MOCK_RESPONSE\", __spreadProps(__spreadValues({}, responseInit), {\n              body: responseStream\n            }),\n            // Transfer response's buffer so it could\n            // be sent over to the worker.\n            responseStream ? [responseStream] : void 0);\n            if (!options.quiet) {\n              context.emitter.once(\"response:mocked\", response2 => {\n                handler.log(request2, response2, parsedRequest);\n              });\n            }\n          });\n        }\n      });\n    } catch (error) {\n      if (error instanceof NetworkError) {\n        messageChannel.postMessage(\"NETWORK_ERROR\", {\n          name: error.name,\n          message: error.message\n        });\n        return;\n      }\n      if (error instanceof Error) {\n        devUtils4.error(`Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`, request.method, request.url, (_b = error.stack) != null ? _b : error);\n        messageChannel.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack\n          })\n        });\n      }\n    }\n  });\n};\n\n// src/browser/utils/requestIntegrityCheck.ts\nfunction requestIntegrityCheck(context, serviceWorker) {\n  return __async(this, null, function* () {\n    context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n    const {\n      payload: actualChecksum\n    } = yield context.events.once(\"INTEGRITY_CHECK_RESPONSE\");\n    if (actualChecksum !== \"b24acb1451c726c44a3a37a0b8092d67\") {\n      throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"b24acb1451c726c44a3a37a0b8092d67\"}).`);\n    }\n    return serviceWorker;\n  });\n}\n\n// src/browser/utils/deferNetworkRequestsUntil.ts\nimport { until as until2 } from \"@open-draft/until\";\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n  window.XMLHttpRequest.prototype.send = function (...args) {\n    until2(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  };\n  const originalFetch = window.fetch;\n  window.fetch = (...args) => __async(this, null, function* () {\n    yield until2(() => predicatePromise);\n    window.fetch = originalFetch;\n    return window.fetch(...args);\n  });\n}\n\n// src/browser/setupWorker/start/createResponseListener.ts\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n    const {\n      payload: responseJson\n    } = message;\n    if ((_a = responseJson.type) == null ? void 0 : _a.includes(\"opaque\")) {\n      return;\n    }\n    const response = new Response(responseJson.body, responseJson);\n    const isMockedResponse = response.headers.get(\"x-powered-by\") === \"msw\";\n    if (isMockedResponse) {\n      context.emitter.emit(\"response:mocked\", response,\n      /**\n       * @todo @fixme In this context, we don't know anything about\n       * the request.\n       */\n      null, responseJson.requestId);\n    } else {\n      context.emitter.emit(\"response:bypass\", response, null, responseJson.requestId);\n    }\n  };\n}\n\n// src/browser/setupWorker/start/utils/validateWorkerScope.ts\nimport { devUtils as devUtils5 } from '../core/utils/internal/devUtils.mjs';\nfunction validateWorkerScope(registration, options) {\n  if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils5.warn(`Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`);\n  }\n}\n\n// src/browser/setupWorker/start/createStartHandler.ts\nvar createStartHandler = context => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = () => __async(this, null, function* () {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\"REQUEST\", createRequestListener(context, options));\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = yield getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n      const [worker, registration] = instance;\n      if (!worker) {\n        const missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils6.formatMessage(`Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`, options.serviceWorker.url) : devUtils6.formatMessage(`Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);\n        throw new Error(missingWorkerMessage);\n      }\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, \"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.send(\"CLIENT_CLOSED\");\n        }\n        window.clearInterval(context.keepAliveInterval);\n      });\n      const integrityCheckResult = yield until3(() => requestIntegrityCheck(context, worker));\n      if (integrityCheckResult.error) {\n        devUtils6.error(`Detected outdated Service Worker: ${integrityCheckResult.error.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);\n      }\n      context.keepAliveInterval = window.setInterval(() => context.workerChannel.send(\"KEEPALIVE_REQUEST\"), 5e3);\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    });\n    const workerRegistration = startWorkerInstance().then(registration => __async(this, null, function* () {\n      const pendingInstance = registration.installing || registration.waiting;\n      if (pendingInstance) {\n        yield new Promise(resolve => {\n          pendingInstance.addEventListener(\"statechange\", () => {\n            if (pendingInstance.state === \"activated\") {\n              return resolve();\n            }\n          });\n        });\n      }\n      yield enableMocking(context, options).catch(error => {\n        throw new Error(`Failed to enable mocking: ${error == null ? void 0 : error.message}`);\n      });\n      return registration;\n    }));\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n    return workerRegistration;\n  };\n};\n\n// src/browser/setupWorker/stop/createStop.ts\nimport { devUtils as devUtils8 } from '../core/utils/internal/devUtils.mjs';\n\n// src/browser/setupWorker/stop/utils/printStopMessage.ts\nimport { devUtils as devUtils7 } from '../core/utils/internal/devUtils.mjs';\nfunction printStopMessage(args = {}) {\n  if (args.quiet) {\n    return;\n  }\n  console.log(`%c${devUtils7.formatMessage(\"Mocking disabled.\")}`, \"color:orangered;font-weight:bold;\");\n}\n\n// src/browser/setupWorker/stop/createStop.ts\nvar createStop = context => {\n  return function stop() {\n    var _a;\n    if (!context.isMockingEnabled) {\n      devUtils8.warn('Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.');\n      return;\n    }\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({\n      quiet: (_a = context.startOptions) == null ? void 0 : _a.quiet\n    });\n  };\n};\n\n// src/browser/setupWorker/start/utils/prepareStartHandler.ts\nimport { mergeRight } from '../core/utils/internal/mergeRight.mjs';\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\n// src/browser/setupWorker/start/createFallbackRequestListener.ts\nimport { BatchInterceptor } from \"@mswjs/interceptors\";\nimport { FetchInterceptor } from \"@mswjs/interceptors/fetch\";\nimport { XMLHttpRequestInterceptor } from \"@mswjs/interceptors/XMLHttpRequest\";\nimport { handleRequest as handleRequest2 } from '../core/utils/handleRequest.mjs';\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", (request, requestId) => __async(this, null, function* () {\n    const response = yield handleRequest2(request, requestId, context.requestHandlers, options, context.emitter, {\n      onMockedResponse(_, {\n        handler,\n        request: request2,\n        parsedRequest\n      }) {\n        if (!options.quiet) {\n          context.emitter.once(\"response:mocked\", response2 => {\n            handler.log(request2, response2, parsedRequest);\n          });\n        }\n      }\n    });\n    if (response) {\n      request.respondWith(response);\n    }\n  }));\n  interceptor.on(\"response\", (response, request, requestId) => {\n    if (response.headers.get(\"x-powered-by\") === \"msw\") {\n      context.emitter.emit(\"response:mocked\", response, request, requestId);\n    } else {\n      context.emitter.emit(\"response:bypass\", response, request, requestId);\n    }\n  });\n  interceptor.apply();\n  return interceptor;\n}\n\n// src/browser/setupWorker/start/createFallbackStart.ts\nfunction createFallbackStart(context) {\n  return function start(options) {\n    return __async(this, null, function* () {\n      context.fallbackInterceptor = createFallbackRequestListener(context, options);\n      printStartMessage({\n        message: \"Mocking enabled (fallback mode).\",\n        quiet: options.quiet\n      });\n      return void 0;\n    });\n  };\n}\n\n// src/browser/setupWorker/stop/createFallbackStop.ts\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n    (_a = context.fallbackInterceptor) == null ? void 0 : _a.dispose();\n    printStopMessage({\n      quiet: (_b = context.startOptions) == null ? void 0 : _b.quiet\n    });\n  };\n}\n\n// src/browser/setupWorker/setupWorker.ts\nimport { devUtils as devUtils9 } from '../core/utils/internal/devUtils.mjs';\nimport { SetupApi } from '../core/SetupApi.mjs';\nimport { mergeRight as mergeRight2 } from '../core/utils/internal/mergeRight.mjs';\nvar SetupWorkerApi = class extends SetupApi {\n  constructor(...handlers) {\n    super(...handlers);\n    this.startHandler = null;\n    this.stopHandler = null;\n    invariant(!isNodeProcess(), devUtils9.formatMessage(\"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"));\n    this.listeners = [];\n    this.context = this.createWorkerContext();\n  }\n  createWorkerContext() {\n    const context = {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null,\n      worker: null,\n      registration: null,\n      requestHandlers: this.currentHandlers,\n      emitter: this.emitter,\n      workerChannel: {\n        on: (eventType, callback) => {\n          this.context.events.addListener(navigator.serviceWorker, \"message\", event => {\n            if (event.source !== this.context.worker) {\n              return;\n            }\n            const message = event.data;\n            if (!message) {\n              return;\n            }\n            if (message.type === eventType) {\n              callback(event, message);\n            }\n          });\n        },\n        send: type => {\n          var _a;\n          (_a = this.context.worker) == null ? void 0 : _a.postMessage(type);\n        }\n      },\n      events: {\n        addListener: (target, eventType, callback) => {\n          target.addEventListener(eventType, callback);\n          this.listeners.push({\n            eventType,\n            target,\n            callback\n          });\n          return () => {\n            target.removeEventListener(eventType, callback);\n          };\n        },\n        removeAllListeners: () => {\n          for (const {\n            target,\n            eventType,\n            callback\n          } of this.listeners) {\n            target.removeEventListener(eventType, callback);\n          }\n          this.listeners = [];\n        },\n        once: eventType => {\n          const bindings = [];\n          return new Promise((resolve, reject) => {\n            const handleIncomingMessage = event => {\n              try {\n                const message = event.data;\n                if (message.type === eventType) {\n                  resolve(message);\n                }\n              } catch (error) {\n                reject(error);\n              }\n            };\n            bindings.push(this.context.events.addListener(navigator.serviceWorker, \"message\", handleIncomingMessage), this.context.events.addListener(navigator.serviceWorker, \"messageerror\", reject));\n          }).finally(() => {\n            bindings.forEach(unbind => unbind());\n          });\n        }\n      },\n      useFallbackMode: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\"\n    };\n    Object.defineProperties(context, {\n      requestHandlers: {\n        get: () => this.currentHandlers\n      }\n    });\n    this.startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n    this.stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n    return context;\n  }\n  start() {\n    return __async(this, arguments, function* (options = {}) {\n      this.context.startOptions = mergeRight2(DEFAULT_START_OPTIONS, options);\n      return yield this.startHandler(this.context.startOptions, options);\n    });\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach(handler => {\n      const {\n        header,\n        callFrame\n      } = handler.info;\n      const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n      console.groupCollapsed(`${pragma} ${header}`);\n      if (callFrame) {\n        console.log(`Declaration: ${callFrame}`);\n      }\n      console.log(\"Handler:\", handler);\n      console.groupEnd();\n    });\n  }\n  stop() {\n    super.dispose();\n    this.context.events.removeAllListeners();\n    this.context.emitter.removeAllListeners();\n    this.stopHandler();\n  }\n};\nfunction setupWorker(...handlers) {\n  return new SetupWorkerApi(...handlers);\n}\nexport { SetupWorkerApi, setupWorker };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}