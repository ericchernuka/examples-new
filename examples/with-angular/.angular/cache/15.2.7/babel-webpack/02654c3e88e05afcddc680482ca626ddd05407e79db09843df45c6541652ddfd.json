{"ast":null,"code":"import _asyncToGenerator from \"/Users/kettanaito/Projects/mswjs/new-examples/node_modules/.pnpm/@babel+runtime@7.20.13/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar __require = /* @__PURE__ */(x => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function (x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\n\n// src/Interceptor.ts\nimport { Logger as Logger2 } from \"@open-draft/logger\";\n\n// src/utils/AsyncEventEmitter.ts\nimport { Logger } from \"@open-draft/logger\";\nimport { Emitter } from \"strict-event-emitter\";\n\n// src/utils/nextTick.ts\nfunction nextTick(callback) {\n  setTimeout(callback, 0);\n}\n\n// src/utils/AsyncEventEmitter.ts\nvar AsyncEventEmitter = class extends Emitter {\n  constructor() {\n    super();\n    this.logger = new Logger(\"async-event-emitter\");\n    this.queue = /* @__PURE__ */new Map();\n    this.readyState = \"ACTIVE\" /* ACTIVE */;\n  }\n\n  on(eventName, listener) {\n    var _this = this;\n    const logger = this.logger.extend(\"on\");\n    logger.info('adding \"%s\" listener...', eventName);\n    if (this.readyState === \"DEACTIVATED\" /* DEACTIVATED */) {\n      logger.info(\"the emitter is destroyed, skipping!\");\n      return this;\n    }\n    return super.on(eventName, /*#__PURE__*/_asyncToGenerator(function* (...args) {\n      const queue = _this.openListenerQueue(eventName);\n      logger.info('awaiting the \"%s\" listener...', eventName);\n      queue.push({\n        args,\n        done: new Promise( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (resolve, reject) {\n            try {\n              yield listener(...args);\n              resolve();\n              logger.info('\"%s\" listener has resolved!', eventName);\n            } catch (error) {\n              logger.info('\"%s\" listener has rejected!', error);\n              reject(error);\n            }\n          });\n          return function (_x, _x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }())\n      });\n    }));\n  }\n  emit(eventName, ...data) {\n    const logger = this.logger.extend(\"emit\");\n    logger.info('emitting \"%s\" event...', eventName);\n    if (this.readyState === \"DEACTIVATED\" /* DEACTIVATED */) {\n      logger.info(\"the emitter is destroyed, skipping!\");\n      return false;\n    }\n    if (this.isInternalEventName(eventName)) {\n      return super.emit(eventName, ...data);\n    }\n    this.openListenerQueue(eventName);\n    logger.info('appending a one-time cleanup \"%s\" listener...', eventName);\n    this.once(eventName, () => {\n      nextTick(() => {\n        this.queue.delete(eventName);\n        logger.info('cleaned up \"%s\" listeners queue!', eventName);\n      });\n    });\n    return super.emit(eventName, ...data);\n  }\n  untilIdle(eventName, filter = () => true) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const listenersQueue = _this2.queue.get(eventName) || [];\n      yield Promise.all(listenersQueue.filter(filter).map(({\n        done\n      }) => done)).finally(() => {\n        _this2.queue.delete(eventName);\n      });\n    })();\n  }\n  openListenerQueue(eventName) {\n    const logger = this.logger.extend(\"openListenerQueue\");\n    logger.info('opening \"%s\" listeners queue...', eventName);\n    const queue = this.queue.get(eventName);\n    if (!queue) {\n      logger.info(\"no queue found, creating one...\");\n      this.queue.set(eventName, []);\n      return [];\n    }\n    logger.info(\"returning an exising queue:\", queue);\n    return queue;\n  }\n  removeAllListeners(eventName) {\n    const logger = this.logger.extend(\"removeAllListeners\");\n    logger.info(\"event:\", eventName);\n    if (eventName) {\n      this.queue.delete(eventName);\n      logger.info('cleared the \"%s\" listeners queue!', eventName, this.queue.get(eventName));\n    } else {\n      this.queue.clear();\n      logger.info(\"cleared the listeners queue!\", this.queue);\n    }\n    return super.removeAllListeners(eventName);\n  }\n  activate() {\n    const logger = this.logger.extend(\"activate\");\n    this.readyState = \"ACTIVE\" /* ACTIVE */;\n    logger.info(\"set state to:\", this.readyState);\n  }\n  deactivate() {\n    const logger = this.logger.extend(\"deactivate\");\n    logger.info(\"removing all listeners...\");\n    this.removeAllListeners();\n    this.readyState = \"DEACTIVATED\" /* DEACTIVATED */;\n    logger.info(\"set state to:\", this.readyState);\n  }\n  isInternalEventName(eventName) {\n    return eventName === \"newListener\" || eventName === \"removeListener\";\n  }\n};\n\n// src/Interceptor.ts\nfunction getGlobalSymbol(symbol) {\n  return globalThis[symbol] || void 0;\n}\nfunction setGlobalSymbol(symbol, value) {\n  globalThis[symbol] = value;\n}\nfunction deleteGlobalSymbol(symbol) {\n  delete globalThis[symbol];\n}\nvar InterceptorReadyState = /* @__PURE__ */(InterceptorReadyState2 => {\n  InterceptorReadyState2[\"INACTIVE\"] = \"INACTIVE\";\n  InterceptorReadyState2[\"APPLYING\"] = \"APPLYING\";\n  InterceptorReadyState2[\"APPLIED\"] = \"APPLIED\";\n  InterceptorReadyState2[\"DISPOSING\"] = \"DISPOSING\";\n  InterceptorReadyState2[\"DISPOSED\"] = \"DISPOSED\";\n  return InterceptorReadyState2;\n})(InterceptorReadyState || {});\nvar Interceptor = class {\n  constructor(symbol) {\n    this.symbol = symbol;\n    this.readyState = \"INACTIVE\" /* INACTIVE */;\n    this.emitter = new AsyncEventEmitter();\n    this.subscriptions = [];\n    this.logger = new Logger2(symbol.description);\n    this.emitter.setMaxListeners(0);\n    this.logger.info(\"constructing the interceptor...\");\n  }\n  checkEnvironment() {\n    return true;\n  }\n  apply() {\n    const logger = this.logger.extend(\"apply\");\n    logger.info(\"applying the interceptor...\");\n    if (this.readyState === \"APPLIED\" /* APPLIED */) {\n      logger.info(\"intercepted already applied!\");\n      return;\n    }\n    const shouldApply = this.checkEnvironment();\n    if (!shouldApply) {\n      logger.info(\"the interceptor cannot be applied in this environment!\");\n      return;\n    }\n    this.readyState = \"APPLYING\" /* APPLYING */;\n    this.emitter.activate();\n    logger.info(\"activated the emiter!\", this.emitter.readyState);\n    const runningInstance = this.getInstance();\n    if (runningInstance) {\n      logger.info(\"found a running instance, reusing...\");\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event);\n        runningInstance.emitter.addListener(event, listener);\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener);\n          logger.info('removed proxied \"%s\" listener!', event);\n        });\n      };\n      nextTick(() => {\n        this.readyState = \"APPLIED\" /* APPLIED */;\n      });\n\n      return;\n    }\n    logger.info(\"no running instance found, setting up a new instance...\");\n    this.setup();\n    this.setInstance();\n    nextTick(() => {\n      this.readyState = \"APPLIED\" /* APPLIED */;\n    });\n  }\n\n  setup() {}\n  on(eventName, listener) {\n    const logger = this.logger.extend(\"on\");\n    if (this.readyState === \"DISPOSING\" /* DISPOSING */ || this.readyState === \"DISPOSED\" /* DISPOSED */) {\n      logger.info(\"cannot listen to events, already disposed!\");\n      return;\n    }\n    logger.info('adding \"%s\" event listener:', eventName, listener.name);\n    this.emitter.on(eventName, listener);\n  }\n  dispose() {\n    const logger = this.logger.extend(\"dispose\");\n    if (this.readyState === \"DISPOSED\" /* DISPOSED */) {\n      logger.info(\"cannot dispose, already disposed!\");\n      return;\n    }\n    logger.info(\"disposing the interceptor...\");\n    this.readyState = \"DISPOSING\" /* DISPOSING */;\n    if (!this.getInstance()) {\n      logger.info(\"no interceptors running, skipping dispose...\");\n      return;\n    }\n    this.clearInstance();\n    logger.info(\"global symbol deleted:\", getGlobalSymbol(this.symbol));\n    if (this.subscriptions.length > 0) {\n      logger.info(\"disposing of %d subscriptions...\", this.subscriptions.length);\n      for (const dispose of this.subscriptions) {\n        dispose();\n      }\n      this.subscriptions = [];\n      logger.info(\"disposed of all subscriptions!\", this.subscriptions.length);\n    }\n    this.emitter.deactivate();\n    logger.info(\"destroyed the listener!\");\n    nextTick(() => {\n      this.readyState = \"DISPOSED\" /* DISPOSED */;\n    });\n  }\n\n  getInstance() {\n    var _a;\n    const instance = getGlobalSymbol(this.symbol);\n    this.logger.info(\"retrieved global instance:\", (_a = instance == null ? void 0 : instance.constructor) == null ? void 0 : _a.name);\n    return instance;\n  }\n  setInstance() {\n    setGlobalSymbol(this.symbol, this);\n    this.logger.info(\"set global instance!\", this.symbol.description);\n  }\n  clearInstance() {\n    deleteGlobalSymbol(this.symbol);\n    this.logger.info(\"cleared global instance!\", this.symbol.description);\n  }\n};\nexport { __require, getGlobalSymbol, deleteGlobalSymbol, InterceptorReadyState, Interceptor };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}