{"ast":null,"code":"var __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nimport { parse } from \"graphql\";\nimport { getPublicUrlFromRequest } from '../request/getPublicUrlFromRequest.mjs';\nimport { devUtils } from './devUtils.mjs';\nimport { jsonParse } from './jsonParse.mjs';\nimport { parseMultipartData } from './parseMultipartData.mjs';\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find(definition => {\n    return definition.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = parse(query);\n    return parseDocumentNode(ast);\n  } catch (error) {\n    return error;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = {\n    variables\n  };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  return __async(this, null, function* () {\n    var _a;\n    const url = new URL(request.url);\n    switch (request.method) {\n      case \"GET\":\n        {\n          const query = url.searchParams.get(\"query\");\n          const variables = url.searchParams.get(\"variables\") || \"\";\n          return {\n            query,\n            variables: jsonParse(variables)\n          };\n        }\n      case \"POST\":\n        {\n          if ((_a = request.headers.get(\"content-type\")) == null ? void 0 : _a.includes(\"multipart/form-data\")) {\n            const responseJson = parseMultipartData(yield request.text(), request.headers);\n            if (!responseJson) {\n              return null;\n            }\n            const _b = responseJson,\n              {\n                operations,\n                map\n              } = _b,\n              files = __objRest(_b, [\"operations\", \"map\"]);\n            const parsedOperations = jsonParse(operations) || {};\n            if (!parsedOperations.query) {\n              return null;\n            }\n            const parsedMap = jsonParse(map || \"\") || {};\n            const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n            return {\n              query: parsedOperations.query,\n              variables\n            };\n          }\n          const requestJson = yield request.json().catch(() => null);\n          if (requestJson == null ? void 0 : requestJson.query) {\n            const {\n              query,\n              variables\n            } = requestJson;\n            return {\n              query,\n              variables\n            };\n          }\n        }\n      default:\n        return null;\n    }\n  });\n}\nfunction parseGraphQLRequest(request) {\n  return __async(this, null, function* () {\n    const input = yield getGraphQLInput(request);\n    if (!input || !input.query) {\n      return;\n    }\n    const {\n      query,\n      variables\n    } = input;\n    const parsedResult = parseQuery(query);\n    if (parsedResult instanceof Error) {\n      const requestPublicUrl = getPublicUrlFromRequest(request);\n      throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n    }\n    return {\n      query: input.query,\n      operationType: parsedResult.operationType,\n      operationName: parsedResult.operationName,\n      variables\n    };\n  });\n}\nexport { parseDocumentNode, parseGraphQLRequest };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}