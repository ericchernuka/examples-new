{"ast":null,"code":"import _asyncToGenerator from \"/Users/kettanaito/Projects/mswjs/new-examples/node_modules/.pnpm/@babel+runtime@7.20.13/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { toInteractiveRequest, uuidv4 } from \"./chunk-RT3ATOJH.mjs\";\nimport { IS_PATCHED_MODULE, Interceptor } from \"./chunk-O7B67YBY.mjs\";\n\n// src/interceptors/fetch/index.ts\nimport { invariant } from \"outvariant\";\nimport { until } from \"@open-draft/until\";\nvar _FetchInterceptor = class extends Interceptor {\n  constructor() {\n    super(_FetchInterceptor.symbol);\n  }\n  checkEnvironment() {\n    return typeof globalThis !== \"undefined\" && typeof globalThis.fetch !== \"undefined\";\n  }\n  setup() {\n    var _this = this;\n    const pureFetch = globalThis.fetch;\n    invariant(!pureFetch[IS_PATCHED_MODULE], 'Failed to patch the \"fetch\" module: already patched.');\n    globalThis.fetch = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (input, init) {\n        var _a;\n        const requestId = uuidv4();\n        const request = new Request(input, init);\n        _this.logger.info(\"[%s] %s\", request.method, request.url);\n        const interactiveRequest = toInteractiveRequest(request);\n        _this.logger.info('emitting the \"request\" event for %d listener(s)...', _this.emitter.listenerCount(\"request\"));\n        _this.emitter.emit(\"request\", interactiveRequest, requestId);\n        _this.logger.info(\"awaiting for the mocked response...\");\n        const resolverResult = yield until( /*#__PURE__*/_asyncToGenerator(function* () {\n          yield _this.emitter.untilIdle(\"request\", ({\n            args: [, pendingRequestId]\n          }) => {\n            return pendingRequestId === requestId;\n          });\n          _this.logger.info(\"all request listeners have been resolved!\");\n          const [mockedResponse2] = yield interactiveRequest.respondWith.invoked();\n          _this.logger.info(\"event.respondWith called with:\", mockedResponse2);\n          return mockedResponse2;\n        }));\n        if (resolverResult.error) {\n          console.error(`${request.method} ${request.url} net::ERR_FAILED`);\n          const error = Object.assign(new TypeError(\"Failed to fetch\"), {\n            cause: resolverResult.error\n          });\n          return Promise.reject(error);\n        }\n        const mockedResponse = resolverResult.data;\n        if (mockedResponse && !((_a = request.signal) == null ? void 0 : _a.aborted)) {\n          _this.logger.info(\"received mocked response:\", mockedResponse);\n          const responseCloine = mockedResponse.clone();\n          _this.emitter.emit(\"response\", responseCloine, interactiveRequest, requestId);\n          const response = new Response(mockedResponse.body, mockedResponse);\n          Object.defineProperty(response, \"url\", {\n            writable: false,\n            enumerable: true,\n            configurable: false,\n            value: request.url\n          });\n          return response;\n        }\n        _this.logger.info(\"no mocked response received!\");\n        return pureFetch(request).then(response => {\n          const responseClone = response.clone();\n          _this.logger.info(\"original fetch performed\", responseClone);\n          _this.emitter.emit(\"response\", responseClone, interactiveRequest, requestId);\n          return response;\n        });\n      });\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true\n    });\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: void 0\n      });\n      globalThis.fetch = pureFetch;\n      this.logger.info('restored native \"globalThis.fetch\"!', globalThis.fetch.name);\n    });\n  }\n};\nvar FetchInterceptor = _FetchInterceptor;\nFetchInterceptor.symbol = Symbol(\"fetch\");\nexport { FetchInterceptor };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}