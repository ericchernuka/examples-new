/* eslint-disable */
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string | number; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** An ISO 8601-encoded date */
  ISO8601Date: { input: string; output: string; }
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: { input: string; output: string; }
};

export type Attachment = {
  __typename?: 'Attachment';
  downloadUrl: Scalars['String']['output'];
  filename: Scalars['String']['output'];
  id: Scalars['ID']['output'];
};

export type Brand = {
  __typename?: 'Brand';
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type Conversation = {
  __typename?: 'Conversation';
  brand: Brand;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  /** The time the most recent message was sent */
  lastMessageSentAt: Scalars['ISO8601DateTime']['output'];
  messages: Array<Message>;
  /** The number of messages in this conversation */
  messagesCount: Scalars['Int']['output'];
  /** Other participants in this conversation */
  providers: Array<ConversationParticipant>;
  /** Whether the patient has read all the messages in this conversation */
  readByPatient: Scalars['Boolean']['output'];
  subject: Scalars['String']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** The connection type for Conversation. */
export type ConversationConnection = {
  __typename?: 'ConversationConnection';
  /** A list of edges. */
  edges: Array<ConversationEdge>;
  /** A list of nodes. */
  nodes: Array<Conversation>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ConversationEdge = {
  __typename?: 'ConversationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output'];
  /** The item at the end of the edge. */
  node: Conversation;
};

export type ConversationParticipant = {
  id: Scalars['ID']['output'];
  name: Name;
};

export type Country = {
  __typename?: 'Country';
  code: Scalars['String']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  provinces: Array<ProvinceState>;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

/** Autogenerated input type of CreateMessage */
export type CreateMessageInput = {
  /** The signed blob ids of the attachments */
  attachments?: InputMaybe<Array<Scalars['String']['input']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The main content of the message */
  content: Scalars['String']['input'];
  /** The id of the conversation being replied to. Leave blank to start a new conversation */
  conversationId?: InputMaybe<Scalars['ID']['input']>;
  /** The subject of the message */
  subject?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateMessage. */
export type CreateMessagePayload = {
  __typename?: 'CreateMessagePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  conversation: Maybe<Conversation>;
  errors: Array<DisplayableError>;
};

export type DisplayableError = {
  __typename?: 'DisplayableError';
  fullMessage: Scalars['String']['output'];
  message: Scalars['String']['output'];
  path: Array<Scalars['String']['output']>;
};

/** Autogenerated input type of Login */
export type LoginInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  oneTimeAccessToken?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of Login. */
export type LoginPayload = {
  __typename?: 'LoginPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  errors: Array<Scalars['String']['output']>;
  jwt: Maybe<Scalars['String']['output']>;
  viewer: Maybe<Patient>;
};

export type Message = {
  __typename?: 'Message';
  attachments: Array<Attachment>;
  content: Scalars['String']['output'];
  conversationId: Scalars['ID']['output'];
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  sender: ConversationParticipant;
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type Mutation = {
  __typename?: 'Mutation';
  /** Start a new conversation */
  createMessage: Maybe<CreateMessagePayload>;
  /**
   * Trades a set of credentials for a JWT. An email is required, as well as one of
   * either a password or a one-time access token
   */
  login: Maybe<LoginPayload>;
  /** Marks a conversation as having been read by the current viewer */
  readConversation: Maybe<ReadConversationPayload>;
  /** Signs up a new patient */
  signup: Maybe<SignupPayload>;
};


export type MutationCreateMessageArgs = {
  input: CreateMessageInput;
};


export type MutationLoginArgs = {
  input: LoginInput;
};


export type MutationReadConversationArgs = {
  input: ReadConversationInput;
};


export type MutationSignupArgs = {
  input: SignupInput;
};

export type Name = {
  __typename?: 'Name';
  firstName: Scalars['String']['output'];
  fullName: Scalars['String']['output'];
  lastName: Scalars['String']['output'];
  legalFullName: Scalars['String']['output'];
  preferredName: Scalars['String']['output'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor: Maybe<Scalars['String']['output']>;
};

export type Patient = ConversationParticipant & {
  __typename?: 'Patient';
  allergies: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['ISO8601DateTime']['output'];
  dateOfBirth: Maybe<Scalars['ISO8601Date']['output']>;
  email: Scalars['String']['output'];
  financialExpectation: Maybe<Scalars['String']['output']>;
  healthCareNumber: Maybe<Scalars['String']['output']>;
  healthCareProvince: Maybe<ProvinceState>;
  id: Scalars['ID']['output'];
  locale: Scalars['String']['output'];
  medicalConditions: Maybe<Scalars['String']['output']>;
  medications: Maybe<Scalars['String']['output']>;
  name: Name;
  phone: Phone;
  province: Maybe<ProvinceState>;
  smsEnabled: Scalars['Boolean']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
  voicemailConsent: Scalars['Boolean']['output'];
};

export type Phone = {
  __typename?: 'Phone';
  areaCode: Scalars['String']['output'];
  e164: Scalars['String']['output'];
  rawNumber: Maybe<Scalars['String']['output']>;
  valid: Scalars['Boolean']['output'];
};

export type Provider = ConversationParticipant & {
  __typename?: 'Provider';
  id: Scalars['ID']['output'];
  name: Name;
};

export type ProvinceState = {
  __typename?: 'ProvinceState';
  code: Scalars['String']['output'];
  country: Country;
  createdAt: Scalars['ISO8601DateTime']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  supported: Scalars['Boolean']['output'];
  updatedAt: Scalars['ISO8601DateTime']['output'];
};

export type Query = {
  __typename?: 'Query';
  /** Gets conversations for the current viewer */
  conversation: Conversation;
  /** Gets conversations for the current viewer */
  conversations: ConversationConnection;
  /** Gets the currently authenticated patient */
  viewer: Maybe<Patient>;
};


export type QueryConversationArgs = {
  id: Scalars['ID']['input'];
};


export type QueryConversationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of ReadConversation */
export type ReadConversationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The ID of a conversation */
  conversationId: Scalars['ID']['input'];
};

/** Autogenerated return type of ReadConversation. */
export type ReadConversationPayload = {
  __typename?: 'ReadConversationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  conversation: Maybe<Conversation>;
};

/** Autogenerated input type of Signup */
export type SignupInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['ISO8601Date']['input']>;
  email: Scalars['String']['input'];
  financialExpectation?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  healthCareNumber?: InputMaybe<Scalars['String']['input']>;
  healthCareProvinceId?: InputMaybe<Scalars['ID']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** The locale of the user */
  locale?: InputMaybe<Scalars['String']['input']>;
  password?: InputMaybe<Scalars['String']['input']>;
  phoneNumber?: InputMaybe<Scalars['String']['input']>;
  preferredName?: InputMaybe<Scalars['String']['input']>;
  provinceId: Scalars['ID']['input'];
};

/** Autogenerated return type of Signup. */
export type SignupPayload = {
  __typename?: 'SignupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId: Maybe<Scalars['String']['output']>;
  errors: Maybe<Array<Scalars['String']['output']>>;
  jwt: Maybe<Scalars['String']['output']>;
  viewer: Maybe<Patient>;
};

export type ViewerQueryVariables = Exact<{ [key: string]: never; }>;


export type ViewerQuery = { __typename?: 'Query', viewer: { __typename?: 'Patient', id: string, name: { __typename?: 'Name', firstName: string, lastName: string } } | null };


export const ViewerDocument = {"kind":"Document","definitions":[{"kind":"OperationDefinition","operation":"query","name":{"kind":"Name","value":"Viewer"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"viewer"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"id"}},{"kind":"Field","name":{"kind":"Name","value":"name"},"selectionSet":{"kind":"SelectionSet","selections":[{"kind":"Field","name":{"kind":"Name","value":"firstName"}},{"kind":"Field","name":{"kind":"Name","value":"lastName"}}]}}]}}]}}]} as unknown as DocumentNode<ViewerQuery, ViewerQueryVariables>;